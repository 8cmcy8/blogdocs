import{_ as i,c as a,a as n,o as e}from"./app-CyJbN2lw.js";const l={};function p(d,s){return e(),a("div",null,s[0]||(s[0]=[n(`<h1 id="计划" tabindex="-1"><a class="header-anchor" href="#计划"><span>计划</span></a></h1><ol><li>《IDA Pro权威指南》三章</li><li>《逆向工程权威指南》十章</li><li>C++ 类有空就看</li></ol><h1 id="《逆向工程权威指南》" tabindex="-1"><a class="header-anchor" href="#《逆向工程权威指南》"><span>《逆向工程权威指南》</span></a></h1><h2 id="第一部分-指令讲解" tabindex="-1"><a class="header-anchor" href="#第一部分-指令讲解"><span>第一部分 指令讲解</span></a></h2><h3 id="第一章-cpu-简介" tabindex="-1"><a class="header-anchor" href="#第一章-cpu-简介"><span>第一章 CPU 简介</span></a></h3><p>这一张没讲什么太重要的，介绍了一下 cpu 架构啥的，然后说明了本书重点要讲的架构</p><div class="hint-container important"><p class="hint-container-title">重要</p><p>三类 arm 指令集：arm 指令集、thumb 模式指令集、arm64 指令集</p><p>虽然这些指令集之间有着千丝万缕的联系，需要强调的是：不同的指令集分别属于不同的指令集架构；一个指令集绝非另一个指令集的变种。</p></div><h3 id="第二章-最简函数" tabindex="-1"><a class="header-anchor" href="#第二章-最简函数"><span>第二章 最简函数</span></a></h3><p>返回预定常量的函数，已经算得上是最简单的函数了。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> f</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-1-x86" tabindex="-1"><a class="header-anchor" href="#_2-1-x86"><span>2.1 x86</span></a></h4><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>f: </span></span>
<span class="line"><span>	mov eax, 123</span></span>
<span class="line"><span>	ret </span></span>
<span class="line"><span>#这个函数仅由两条指令构成：第一条指令把数值123存放在EAX寄存器里；根据函数调用约定①，后面一条指令会把EAX的值当作返回值传递给调用者函数，而调用者函数（caller）会从EAX寄存器里取值，把它当作返回结果</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-arm" tabindex="-1"><a class="header-anchor" href="#_2-2-arm"><span>2.2 ARM</span></a></h4><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>f PROC # PROC过程标识符，作用就是声明</span></span>
<span class="line"><span>	MOV r0,#0x7b ; 123</span></span>
<span class="line"><span>	BX  lr   </span></span>
<span class="line"><span>	ENDP #表示结束</span></span>
<span class="line"><span># proc是定义子程序的伪指令，位置在子程序的开始处，它和endp分别表示子程序定义的开始和结束两者必须成对出现。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-3-mips" tabindex="-1"><a class="header-anchor" href="#_2-3-mips"><span>2.3 MIPS</span></a></h4><div class="hint-container important"><p class="hint-container-title">重要</p><p>为什么赋值指令LI和转移指令J/JR的位置反过来了？这属于RISC精简指令集的特性之一——分支（转移）指令延迟槽(Branch delay slot)的现象。简单地说，不管分支（转移）发生与否，位于分支指令后面的一条指令（在延时槽里的指令），总是被先于分支指令提交。这是RISC精简指令集的一种特例，我们不必在此处深究。总之，转移指令后面的这条赋值指令实际上是在转移指令之前运行的。</p></div><p>在MIPS指令里，寄存器有两种命名方式。一种是以数字命名（$0<sub>$31），另一种则是以伪名称（pseudoname）命名（$V0</sub>VA0，依此类推）。在GCC编译器生成的汇编指令中，寄存器都采用数字方式命名。</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>j $31  </span></span>
<span class="line"><span>li $2,123 # 0x7b</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li><code>j</code> 是MIPS汇编语言中的跳转指令（Jump），用于无条件跳转到指定的地址执行代码。</li><li><code>$31</code> 是MIPS寄存器集中的特殊寄存器，名为<code>ra</code>（Return Address），通常用于存储子程序返回时的地址。</li><li><code>li</code> 是MIPS汇编语言中的加载立即数（Load Immediate）指令的简写，用于将一个立即数（即直接写在指令中的数）加载到指定的寄存器中。</li><li><code>$2</code> 是MIPS寄存器集中的一个通用寄存器。</li></ul></div><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>jr $ra  </span></span>
<span class="line"><span>li $v0, 0x7B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li><code>$v0</code> 是MIPS寄存器集中的一个通用寄存器，但在MIPS的ABI（Application Binary Interface）中，它经常被用作系统调用的返回值寄存器。然而，在普通的MIPS汇编代码中，它也可以像其他通用寄存器一样被使用。</li><li><code>j</code> 指令直接跳转到指定的地址或标签，而 <code>jr</code> 指令跳转到寄存器中存储的地址。<code>j</code> 指令更适用于在程序中无条件跳转到任意位置，而 <code>jr</code> 指令通常用于函数调用的返回，通过跳转回 <code>$ra</code> 寄存器中保存的返回地址来实现。</li></ul></div><h3 id="第三章-hello-world" tabindex="-1"><a class="header-anchor" href="#第三章-hello-world"><span>第三章 Hello,world!</span></a></h3><p>现给出最著名的程序</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &lt;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">stdio.h</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">	printf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello, world</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\n</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">           </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-1-x86" tabindex="-1"><a class="header-anchor" href="#_3-1-x86"><span>3.1 x86</span></a></h4><h5 id="_3-1-1-msvc" tabindex="-1"><a class="header-anchor" href="#_3-1-1-msvc"><span>3.1.1 MSVC</span></a></h5><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>CONST   SEGMENT  </span></span>
<span class="line"><span>    $SG3830 DB &#39;hello, world&#39;, 0AH, 00H  ; 字符串 &#39;hello, world&#39; 加上换行符和字符串结束符  </span></span>
<span class="line"><span>CONST   ENDS  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>PUBLIC _main  </span></span>
<span class="line"><span>EXTRN   _printf:PROC                     ; 声明外部过程 _printf  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>_TEXT    SEGMENT  </span></span>
<span class="line"><span>_main    PROC  </span></span>
<span class="line"><span>    push    ebp                          ; 保存旧的 ebp  </span></span>
<span class="line"><span>    mov     ebp, esp                     ; 设置新的栈帧  </span></span>
<span class="line"><span>    push    OFFSET $SG3830                ; 将字符串的地址压入栈中  </span></span>
<span class="line"><span>    call    _printf                      ; 调用 printf 函数  </span></span>
<span class="line"><span>    add     esp, 4                       ; 清理栈（这里假设 _printf 消耗了 4 字节的栈空间）  </span></span>
<span class="line"><span>    xor     eax, eax                     ; 设置 eax 为 0，表示程序正常退出  </span></span>
<span class="line"><span>    pop     ebp                          ; 恢复旧的 ebp  </span></span>
<span class="line"><span>    ret                                  ; 返回  </span></span>
<span class="line"><span>_main    ENDP  </span></span>
<span class="line"><span>_TEXT    ENDS  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>END                                      ; 表示文件结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li><p><code>OFFSET</code> 是一个操作符，用于获取某个标签（label）、变量名或常量在内存中的偏移地址（offset address）。</p></li><li><p>我们会发现编译器在字符串常量的尾部添加了十六进制的数字0，即00h。依据C/C++字符串的标准规范，编译器要为这个字符串常量添加结束标志（即数值为零的单个字节）。</p></li></ul></div><p>上述程序的源代码等效于：</p><div class="language-c# line-numbers-mode" data-highlighter="shiki" data-ext="c#" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">#</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">include &lt;stdio.h&gt;  </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 声明一个指向 const char 的指针，指向字符串 &quot;hello, world\\n&quot;  </span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">const</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> char</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">SG3830</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello, world</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">\\n</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 使用 printf 函数打印字符串  </span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    printf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">%s</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> SG3830</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 或者更简单地，因为 SG3830 已经是一个指向字符串的指针  </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // printf(SG3830);  </span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">  </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_3-1-2-gcc" tabindex="-1"><a class="header-anchor" href="#_3-1-2-gcc"><span>3.1.2 GCC</span></a></h5><p>在 IDA 中观察到的汇编指令</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Main PROC NEAR  </span></span>
<span class="line"><span>    var_10 = dword ptr -10h  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    push    ebp  </span></span>
<span class="line"><span>    mov     ebp, esp  </span></span>
<span class="line"><span>    and     esp, 0FFFFFFF0h  </span></span>
<span class="line"><span>    sub     esp, 10h  </span></span>
<span class="line"><span>    mov     eax, offset aHelloWorld ; &quot;hello, world\\n&quot;  </span></span>
<span class="line"><span>    mov     [esp+10h+var_10], eax   ; 注意：这行代码的意图可能不清晰或错误  </span></span>
<span class="line"><span>    call    _printf  </span></span>
<span class="line"><span>    mov     eax, 0  </span></span>
<span class="line"><span>    leave  </span></span>
<span class="line"><span>    retn  </span></span>
<span class="line"><span>Main ENDP  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>; 假设aHelloWorld是在其他地方定义的字符串常量  </span></span>
<span class="line"><span>; aHelloWorld DB &#39;hello, world\\n&#39;, 0 ; 字符串定义通常包括末尾的0作为结束符</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li><code>and esp, 0FFFFFFF0h</code> 这条指令是用来对栈指针寄存器 <code>ESP</code> 进行位与（AND）操作的，目的是将 <code>ESP</code> 的值向下调整到离它最近的16字节,说白了就是 2 进制下低四位清零。<strong>如果地址位没有对齐，那么CPU可能需要访问两次内存才能获得栈内数据。虽然在8字节边界处对齐就可以满足32位x86 CPU和64位x64 CPU的要求，但是主流编译器的编译规则规定“程序访问的地址必须向16字节对齐（被16整除）”。人们还是为了提高指令的执行效率而特意拟定了这条编译规范。</strong></li><li>LEAVE 指令，等效于“ MOV ESP, EBP ”和“ POP EBP ”两条指令。可见，这个指令调整了数据栈指针 ESP，并将 EBP 的数值恢复到调用这个函数之前的初始状态。</li></ul></div><h5 id="_3-1-3-gcc-at-t-语体" tabindex="-1"><a class="header-anchor" href="#_3-1-3-gcc-at-t-语体"><span>3.1.3 GCC:AT&amp;T 语体</span></a></h5><p>AT &amp; T语体同样是汇编语言的显示风格。这种语体在UNIX之中较为常见。</p><p>去除掉大量的汇编宏得到的程序</p><div class="language-assembly line-numbers-mode" data-highlighter="shiki" data-ext="assembly" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>.LC0:        .string &quot;hello, world\\n&quot;  </span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>main:  </span></span>
<span class="line"><span>    pushl   %ebp           ; 保存旧的基指针  </span></span>
<span class="line"><span>    movl    %esp, %ebp     ; 将栈指针的值复制到基指针，设置新的栈帧  </span></span>
<span class="line"><span>    andl    $-16, %esp     ; 将栈指针向下调整到16字节的边界  </span></span>
<span class="line"><span>    subl    $16, %esp      ; 为局部变量和可能的函数调用预留空间  </span></span>
<span class="line"><span>    movl    $.LC0, (%esp)  ; 将字符串的地址压入栈中，作为printf的参数  </span></span>
<span class="line"><span>    call    printf         ; 调用printf函数打印字符串  </span></span>
<span class="line"><span>    movl    $0, %eax       ; 设置返回值0，表示程序成功执行  </span></span>
<span class="line"><span>    leave                  ; 恢复旧的栈帧（mov %ebp, %esp; pop %ebp）  </span></span>
<span class="line"><span>    ret                    ; 返回调用者</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container important"><p class="hint-container-title">重要</p><ul><li><p>运算表达式（operands，即运算单元）的书写顺序相反。</p><p>Intel 格式：&lt;指令&gt;&lt;目标&gt;&lt;源&gt;。</p><p>AT &amp; T 格式：&lt;指令&gt;&lt;源&gt;&lt;目标&gt;</p></li><li><p>AT &amp; T语体中，在寄存器名称之前使用百分号（%）标记，在立即数之前使用美元符号（$）标记。AT &amp; T语体使用圆括号，而Intel语体则使用方括号。</p></li><li><p>AT &amp; T语体里，每个运算操作符都需要声明操作数据的类型：</p><p>－q－quad（64位）</p><p>－l指代32位long型数据。</p><p>－w指代16位word型数据。</p><p>－b指代8位byte型数据。</p></li></ul></div><h4 id="_3-2-x86-64" tabindex="-1"><a class="header-anchor" href="#_3-2-x86-64"><span>3.2 x86-64</span></a></h4>`,40)]))}const t=i(l,[["render",p]]),r=JSON.parse('{"path":"/article/z06ro1kj/","title":"第四次","lang":"zh-CN","frontmatter":{"title":"第四次","createTime":"2024/10/08 20:00","permalink":"/article/z06ro1kj/","cover":"https://vip4.yunpng.top/2025/03/27/67e4d59394cf5.jpg"},"headers":[],"readingTime":{"minutes":6.46,"words":1937},"git":{},"filePathRelative":"日常记录/第四次.md","categoryList":[{"id":"b39b66","sort":10000,"name":"日常记录"}],"bulletin":true}');export{t as comp,r as data};
